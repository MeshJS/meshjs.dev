---
title: "How to Build Multi-Signature Minting Transactions on Cardano"
description: "Implement multi-sig NFT minting with the Mesh TypeScript blockchain SDK for Cardano dApp development. Coordinate signatures between browser and server wallets."
---
import Link from "fumadocs-core/link";
import { HowToSchema } from "@/components/seo";

<HowToSchema
  name="Build Multi-Signature Minting Transactions on Cardano"
  description="Implement multi-sig NFT minting where a user pays for minting but the application controls the minting policy."
  totalTime="PT45M"
  steps={[
    { name: "Connect user wallet", text: "Connect the user's browser wallet and get their address and UTxOs using BrowserWallet or CardanoWallet component." },
    { name: "Build transaction on server", text: "Initialize provider and application wallet, define forging script and NFT metadata, build minting transaction using user's UTxOs." },
    { name: "User signs transaction", text: "Return unsigned transaction to client, user signs with partial signing enabled." },
    { name: "Application signs and submits", text: "Backend adds its signature and submits the fully signed transaction to the blockchain." }
  ]}
/>

Multi-signature (multi-sig) transactions require multiple parties to sign before the transaction can be submitted to the Cardano blockchain. This is essential for NFT minting services where a user pays for minting but the application controls the minting policy in JavaScript Web3 projects.

**The multi-sig minting flow:**
1. **Client wallet** — User's browser wallet provides payment UTxOs
2. **Application wallet** — Server-side wallet holds the forging script and signs the mint

This guide shows you how to build a complete multi-sig minting system using the Mesh Cardano SDK for dApp development. View the <Link href="https://github.com/MeshJS/mesh/blob/main/apps/playground/src/pages/guides/multisig-minting/demo.tsx">complete source code on GitHub</Link>.

## Step 1: How Do You Connect the User's Wallet?

Connect the user's browser wallet and get their address and UTxOs:

```tsx
import { BrowserWallet } from '@meshsdk/core';
const wallet = await BrowserWallet.enable(walletName);
```

Or use the React blockchain `CardanoWallet` component:

```tsx
import { CardanoWallet, useWallet } from "@meshsdk/react";

export default function Page() {
  const { wallet, connected } = useWallet();

  return <CardanoWallet />
}
```

Get the client's address and UTXOs:

```tsx
const recipientAddress = await wallet.getChangeAddress();
const utxos = await wallet.getUtxos();
```

Select only the UTxOs needed for the minting fee:

```tsx
const assetMap = new Map<Unit, Quantity>();
assetMap.set("lovelace", mintingFee);
const selectedUtxos = experimentalSelectUtxos(assetMap, utxos, "5000000");
```

Send `selectedUtxos` and `recipientAddress` to your backend API.

## Step 2: How Do You Build the Transaction on the Server?

On your backend (Next.js API routes, Express, etc.), initialize the provider and application wallet:

```tsx
const provider = new BlockfrostProvider(
  '<blockfrost key here>'
);

const meshWallet = new MeshWallet({
  networkId: 0,
  fetcher: provider,
  submitter: provider,
  key: {
    type: 'mnemonic',
    words: yourMnemonic,
  },
});
```

Define the forging script:

```tsx
const meshWalletAddress = meshWallet.getChangeAddress();
const forgingScript = ForgeScript.withOneSignature(meshWalletAddress);
```

Define the NFT metadata (CIP-25 format):

```tsx
const assetName = 'MeshToken';

const assetMetadata: AssetMetadata = {
  name: 'Mesh Token',
  image: 'ipfs://QmRzicpReutwCkM6aotuKjErFCUD213DpwPq6ByuzMJaua',
  mediaType: 'image/jpg',
  description: 'This NFT was minted by Mesh (https://meshjs.dev/).',
};
```

Build the minting transaction using the user's UTxOs as inputs:

```tsx
import { MeshTxBuilder, resolveScriptHash, stringToHex } from '@meshsdk/core';

const policyId = resolveScriptHash(forgingScript);
const tokenNameHex = stringToHex(assetName);
const metadata = { [policyId]: { [assetName]: assetMetadata } };

const txBuilder = new MeshTxBuilder({
  fetcher: provider,
});

// Add user's UTXOs as inputs
userUtxos.forEach(utxo => {
  txBuilder.txIn(utxo.input.txHash, utxo.input.outputIndex, utxo.output.amount, utxo.output.address);
});

const unsignedTx = await txBuilder
  .mint("1", policyId, tokenNameHex)
  .mintingScript(forgingScript)
  .txOut(recipientAddress, [{ unit: policyId + tokenNameHex, quantity: "1" }])
  .txOut(bankWalletAddress, [{ unit: "lovelace", quantity: mintingFee }])
  .metadataValue(721, metadata)
  .changeAddress(recipientAddress)
  .complete();
```

Return the unsigned transaction to the client.

## Step 3: How Does the User Sign?

The user signs with partial signing enabled (`true`) since another signature is required:

```tsx
const signedTx = await wallet.signTx(unsignedTx, true);
```

Send the partially signed transaction back to the server.

## Step 4: How Does the Application Sign and Submit?

The backend adds its signature and submits:

```tsx
const meshWalletSignedTx = await meshWallet.signTx(signedTx, true);
const txHash = await meshWallet.submitTx(meshWalletSignedTx);
```

The transaction is now fully signed and submitted to the Cardano blockchain.

## What Security Considerations Apply?

- **Never expose mnemonic phrases** in client-side code
- **Validate user UTxOs** before building transactions
- **Set reasonable minting fees** to cover transaction costs
- **Implement rate limiting** to prevent abuse

## What Should You Explore Next?

- View the <Link href="https://github.com/MeshJS/mesh/blob/main/apps/playground/src/pages/guides/multisig-minting/demo.tsx">complete example code</Link>
- Learn about <Link href="/guides/smart-contract-transactions">smart contract transactions</Link>
- Explore <Link href="/apis/txbuilder/minting">minting transaction options</Link>