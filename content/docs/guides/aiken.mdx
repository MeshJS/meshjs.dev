---
title: "Aiken Hello World"
icon: "guides/aiken.png"
---
import Link from "fumadocs-core/link";

Aiken is a functional programming language for Cardano smart contract development. It prioritizes on-chain execution and offers a user-friendly approach for building secure and efficient smart contracts.

This tutorial walks you through writing a smart contract in Aiken and creating two transactions to lock and unlock assets on the Cardano blockchain.

Try the <Link href="https://aiken-template.meshjs.dev/">live demo</Link>. View the code on the <Link href="https://github.com/MeshJS/aiken-next-ts-template/tree/main">GitHub repository</Link>.

## System setup

Set up your system to compile Aiken smart contracts. Skip this section if you have already set up your system or do not wish to compile the contract.

Check the installation instructions on the <Link href="https://aiken-lang.org/installation-instructions">Aiken website</Link> for more information.

### Using aikup (on Linux & MacOS only) [!toc]

Linux and MacOS users can use the utility tool to download and manage Aiken's pre-compiled executables.

Install the Aiken CLI:

```tsx
$ curl -sSfL https://install.aiken-lang.org | bash
$ aikup
```

### From sources (all platforms) [!toc]

Aiken is written in Rust. Install Rust and Cargo to compile the smart contract. Install Rust via the <Link href="https://www.rust-lang.org/">Rust website</Link>.

Install Cargo, the Rust package manager, via the <Link href="https://doc.rust-lang.org/stable/book/ch01-01-installation.html">Cargo website</Link>.

Verify installation:

```tsx
$ rustc --version
$ cargo --version
```

Install the Aiken CLI:

```tsx
$ cargo install aiken
```

### Check your installation [!toc]

Verify the Aiken CLI installation:

```tsx
$ aiken -V
```

If issues arise, check the <Link href="https://aiken-lang.org/installation-instructions">Aiken website</Link>.

## Writing a smart contract with Aiken

Write a smart contract in Aiken and create two transactions to lock and unlock assets.

Read more about this example on the <Link href="https://aiken-lang.org/example--hello-world/basics">Aiken website</Link>.

### Create a new project [!toc]

Create a new project. Refer to <Link href="/guides/nextjs">this guide</Link> for creating a new Next.js project.

Create a new Aiken project within this project folder:

```tsx
$ aiken meshjs/hello_world
$ cd hello_world
$ aiken check
```

Run `aiken check` to verify your project.

### Write the smart contract [!toc]

Create `validators/hello_world.ak`:

```tsx
use aiken/hash.{Blake2b_224, Hash}
use aiken/list
use aiken/transaction.{ScriptContext}
use aiken/transaction/credential.{VerificationKey}

type Datum {
  owner: Hash<Blake2b_224, VerificationKey>,
}

type Redeemer {
  msg: ByteArray,
}

validator {
  fn hello_world(datum: Datum, redeemer: Redeemer, context: ScriptContext) -> Bool {
    let must_say_hello =
      redeemer.msg == "Hello, World!"

    let must_be_signed =
      list.has(context.transaction.extra_signatories, datum.owner)

    must_say_hello && must_be_signed
  }
}
```

This validator checks that the redeemer message is "Hello, World!" and that the transaction is signed by the datum owner. Returns `true` if both conditions are met; otherwise `false`.

Compile the smart contract:

```tsx
$ aiken build
```

This generates `plutus.json` in the root folder. This file is a <Link href="https://cips.cardano.org/cip/CIP-57">CIP-0057 Plutus blueprint</Link>, describing your on-chain contract and its binary interface.

## Creating locking transaction

### Preparing the frontend [!toc]

Prepare the frontend to allow users to lock and unlock assets.

Install `cbor`:

```tsx
$ npm install cbor
```

Create a `data` folder and copy `plutus.json` into it.

Open `pages/index.tsx` and import the packages:

```tsx
import {
  resolvePlutusScriptAddress,
  Transaction,
  KoiosProvider,
  resolveDataHash,
  resolvePaymentKeyHash,
} from "@meshsdk/core";
import type { PlutusScript, Data } from "@meshsdk/core";
import { CardanoWallet, useWallet } from "@meshsdk/react";

import plutusScript from "../data/plutus.json";
import cbor from "cbor";
```

### Importing the contract [!toc]

Import the contract:

```tsx
const script: PlutusScript = {
  code: cbor
    .encode(Buffer.from(plutusScript.validators[0].compiledCode, "hex"))
    .toString("hex"),
  version: "V2",
};
const scriptAddress = resolvePlutusScriptAddress(script, 0);
```

Use `plutus.json` to create the script and `resolvePlutusScriptAddress` to resolve the address.

We encode the compiled validator code with cbor because the validator uses a flat format, unlike the format expected by cardano-cli and the serialization library.

### Locking assets [!toc]

Create the transaction to lock assets:

```tsx
const hash = resolvePaymentKeyHash((await wallet.getUsedAddresses())[0]);
const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const tx = new Transaction({ initiator: wallet }).sendLovelace(
  {
    address: scriptAddress,
    datum: { value: datum },
  },
  "5000000"
);

const unsignedTx = await tx.build();
const signedTx = await wallet.signTx(unsignedTx);
const txHash = await wallet.submitTx(signedTx);
```

This transaction locks assets. `resolvePaymentKeyHash` resolves the wallet's key hash. `sendLovelace` sends lovelace to the script address.

The contract requires the owner's address in the datum. We build, sign, and submit the transaction.

## Unlocking assets

Create the transaction to unlock assets.

Retrieve the UTXO of the locked assets:

```tsx
async function _getAssetUtxo({ scriptAddress, asset, datum }) {
  const utxos = await koios.fetchAddressUTxOs(scriptAddress, asset);

  const dataHash = resolveDataHash(datum);

  let utxo = utxos.find((utxo: any) => {
    return utxo.output.dataHash == dataHash;
  });

  return utxo;
}
```

Create the unlock transaction:

```tsx
const scriptAddress = resolvePlutusScriptAddress(script, 0);

const address = (await wallet.getUsedAddresses())[0];
const hash = resolvePaymentKeyHash(address);
const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const assetUtxo = await _getAssetUtxo({
  scriptAddress: scriptAddress,
  asset: "lovelace",
  datum: datum,
});

const redeemer = { data: { alternative: 0, fields: ['Hello, World!'] } };

// create the unlock asset transaction
const tx = new Transaction({ initiator: wallet })
  .redeemValue({
    value: assetUtxo,
    script: script,
    datum: datum,
    redeemer: redeemer,
  })
  .sendValue(address, assetUtxo)
  .setRequiredSigners([address]);

const unsignedTx = await tx.build();
const signedTx = await wallet.signTx(unsignedTx, true);
const txHash = await wallet.submitTx(signedTx);
```

This transaction unlocks assets. `resolvePlutusScriptAddress` resolves the script address. `resolvePaymentKeyHash` resolves the wallet's key hash.

`_getAssetUtxo` retrieves the locked asset UTXO. `redeemValue` redeems the assets. `sendValue` sends assets to the owner. `setRequiredSigners` sets the required signers.

The validator requires "Hello, World!" as the redeemer message. We build, sign, and submit the transaction.

Check the full code on <Link href="https://github.com/MeshJS/aiken-next-ts-template/blob/main/pages/index.tsx">GitHub</Link>.