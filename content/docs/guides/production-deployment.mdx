---
title: "How to Deploy Cardano dApps to Production"
description: "Security best practices, deployment checklists, and error handling for production Cardano dApp development with the Mesh TypeScript blockchain SDK."
---
import Link from "fumadocs-core/link";
import { HowToSchema } from "@/components/seo";

<HowToSchema
  name="Deploy Cardano dApps to Production"
  description="Comprehensive checklist for deploying secure, reliable Cardano dApps to production environments."
  totalTime="PT90M"
  steps={[
    { name: "Secure private keys", text: "Use browser wallets for user keys, isolate server-side signing, implement audit logging." },
    { name: "Validate transactions", text: "Check amount bounds, address formats, asset verification, and metadata limits." },
    { name: "Audit smart contracts", text: "Have contracts professionally audited, test thoroughly with TxTester and testnets." },
    { name: "Protect API keys", text: "Proxy blockchain requests through backend, implement rate limiting, rotate keys periodically." },
    { name: "Configure providers", text: "Set up primary and fallback providers with health checks for redundancy." },
    { name: "Implement error handling", text: "Handle transaction failures gracefully, manage UTxO contention, implement provider failover." },
    { name: "Set up monitoring", text: "Track transaction metrics, user metrics, and infrastructure metrics with alerting." }
  ]}
/>

Deploying Cardano dApps to production requires careful attention to security, reliability, and user experience. This guide covers essential practices for enterprise-grade Cardano dApp development and JavaScript Web3 deployment—from private key management to monitoring and disaster recovery using the Mesh Cardano SDK.

## What Are the Security Best Practices?

### Private Key Management

Never expose private keys in client-side code. For production applications:

**Browser wallets only** - Let users manage their own keys through wallet extensions. The Mesh Cardano SDK's `BrowserWallet` class handles CIP-30 wallet connections securely without your application touching private keys.

**Server-side signing** - When your application must sign transactions (automated systems, treasury management), isolate signing in secure backend services:

- Use environment variables or secret management services for keys
- Run signing services in isolated network segments
- Implement audit logging for all signing operations
- Consider hardware security modules (HSMs) for high-value operations

### Transaction Validation

Validate all transaction parameters before building:

- **Amount bounds** — Check that values are positive and within expected ranges
- **Address format** — Validate recipient addresses before sending funds
- **Asset verification** — Confirm policy IDs and asset names match expectations
- **Metadata limits** — Ensure metadata fits within protocol limits

### Smart Contract Security

For applications interacting with Cardano smart contracts:

- **Audit contracts** — Have Cardano smart contracts professionally audited before mainnet deployment
- **Test thoroughly** — Use the Mesh SDK's `TxTester` and testnet deployments
- **Validate datums** — Check datum structure matches contract expectations
- **Monitor contracts** — Track contract interactions post-deployment

### API Key Protection

Never expose provider API keys in client-side code:

- Proxy blockchain requests through your backend
- Implement rate limiting to prevent abuse
- Use separate API keys for development and production
- Rotate keys periodically and after any potential exposure

## What Should Your Deployment Checklist Include?

### Pre-Launch

**Infrastructure:**
- [ ] Provider API keys stored securely (not in client bundle)
- [ ] Backend proxy configured for blockchain queries
- [ ] Rate limiting implemented for API endpoints
- [ ] Error monitoring and alerting configured
- [ ] Load testing completed for expected traffic

**Smart Contracts:**
- [ ] Contracts audited by independent party
- [ ] Testnet deployment validated thoroughly
- [ ] Contract addresses verified on mainnet
- [ ] Reference scripts deployed if used
- [ ] Monitoring configured for contract interactions

**Application:**
- [ ] All console.log statements removed from production build
- [ ] Source maps disabled or properly secured
- [ ] CSP headers configured appropriately
- [ ] HTTPS enforced with valid certificates
- [ ] Input validation comprehensive

### Network Configuration

**Provider Selection:**

For production applications, configure provider redundancy:

- Primary provider for normal operations
- Fallback provider for outages
- Health checks to detect provider issues

Consider provider characteristics:

| Provider | Strength | Consideration |
|----------|----------|---------------|
| Blockfrost | Reliability, documentation | Rate limits on free tier |
| Koios | Free tier, decentralized | Self-hosted option available |
| Maestro | Rich data, marketplace support | Enterprise pricing |
| Self-hosted Ogmios | Full control, no rate limits | Infrastructure overhead |

**Network Selection:**

- **Preview** — Testing new features, unstable
- **Preprod** — Production-like testing, recommended for staging
- **Mainnet** — Production deployment

## How Should You Handle Errors?

### Transaction Failures

Handle transaction failures gracefully:

**Validation errors** - Catch before submission:
- Insufficient funds for transaction
- Invalid addresses
- Missing required UTxOs
- Script validation failures

**Submission errors** - Handle post-validation:
- Network connectivity issues
- Provider rate limiting
- UTxO contention (already spent)
- Mempool congestion

**User communication:**
- Display clear error messages, not technical stack traces
- Provide actionable next steps (retry, check wallet, etc.)
- Log technical details for debugging without exposing to users

### UTxO Contention

In high-traffic applications, UTxOs may be spent between query and submission:

**Detection** - Watch for "UTxO already spent" errors

**Prevention strategies:**
- Minimize time between UTxO query and transaction submission
- Implement optimistic locking in backend services
- Use queue systems for sequential transaction building
- Design smart contracts to minimize UTxO contention

### Provider Failover

Implement automatic failover when providers fail:

**Health monitoring:**
- Track response times and error rates
- Set thresholds for failover triggering
- Alert on sustained provider issues

**Failover logic:**
- Maintain multiple provider configurations
- Switch to backup on primary failure
- Auto-recover to primary when healthy

## How Do You Optimize Performance?

### Bundle Size

Minimize client bundle size:

- Import specific modules rather than entire packages
- Use tree shaking in your build configuration
- Lazy load Mesh components not needed at initial page load
- Consider code splitting for wallet-specific features

### Caching Strategies

Reduce redundant blockchain queries:

- Cache UTxO queries with short TTL (5-30 seconds)
- Cache protocol parameters longer (update epoch boundaries)
- Cache resolved metadata (CIP-25 NFT metadata)
- Invalidate caches on transaction submission

### Transaction Optimization

Build efficient transactions:

- Batch multiple outputs in single transactions when possible
- Use reference scripts to reduce transaction size
- Minimize datum sizes in smart contract interactions
- Consider inline datums for frequently accessed data

## What Should You Monitor?

### Key Metrics

Track these metrics for production dApps:

**Transaction metrics:**
- Submission success rate
- Average confirmation time
- Failed transaction breakdown by error type
- Transaction fee distribution

**User metrics:**
- Wallet connection success rate
- Transaction abandonment rate
- Error frequency by type

**Infrastructure metrics:**
- Provider response times
- API endpoint latency
- Error rates by endpoint

### Alerting

Configure alerts for:

- Sustained transaction failure rates above threshold
- Provider connectivity issues
- Smart contract interaction anomalies
- Unusual transaction patterns (potential attacks)

### Logging

Structure logs for analysis:

- Include correlation IDs for transaction flows
- Log transaction hashes for blockchain correlation
- Avoid logging sensitive data (addresses may be semi-sensitive)
- Retain logs for compliance requirements

## What Are the Compliance Requirements?

For enterprise Cardano dApp deployments, consider:

**Regulatory:**
- Know Your Customer (KYC) requirements
- Anti-Money Laundering (AML) monitoring
- Geographic restrictions on services
- Tax reporting obligations

**Data protection:**
- GDPR compliance for EU users
- Data retention policies
- User consent mechanisms
- Right to deletion implementation

**Audit trails:**
- Transaction logging for compliance review
- Access control documentation
- Change management records

## How Do You Plan for Disaster Recovery?

### Backup Strategies

Maintain recovery capabilities:

- Document all deployed contract addresses
- Backup parameterized script configurations
- Store reference script deployment information
- Document provider configurations

### Incident Response

Prepare for security incidents:

- Define escalation procedures
- Document emergency contact information
- Prepare communication templates for users
- Test recovery procedures periodically

## What Should You Do Next?

After completing this checklist:

- <Link href="/providers">Configure providers</Link> for your deployment environment
- <Link href="/guides/aiken">Review smart contract best practices</Link> if using Plutus
- <Link href="https://discord.gg/dH48jH3BKa">Join the community</Link> for ongoing support

Production deployment is an iterative process. Monitor your application closely post-launch and refine based on real-world usage patterns.
