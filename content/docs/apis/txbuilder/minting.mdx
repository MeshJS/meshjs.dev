---
title: "Mint and Burn Assets"
description: "Minting and burning assets with Native Script and Plutus Script"
icon: FireIcon
---
import Link from "fumadocs-core/link";

Minting and burning assets with Native Script and Plutus Script

Minting and burning assets is a common operation in blockchain applications. In the Cardano ecosystem, minting and burning are achieved through Native Scripts and Plutus Scripts.

To view a video demonstration of this feature of the MeshSDK, navigate to the video guide <Link href="/guides/nft-collection">Mint an NFT Collection</Link>.

In the code snippet, you will find `txBuilder`, which is an instance of `MeshTxBuilder`, with powerful low-level APIs that allow you to build transactions. Here's how to initialize **MeshTxBuilder**.

```tsx
const txBuilder = new MeshTxBuilder({
  fetcher: provider, // get a provider https://meshjs.dev/providers
  verbose: true,
});
```

In this page, you will find the APIs to create transactions for minting and burning assets.


## Minting with One Signature

In this section, we will see how to mint native assets with a `MeshTxBuilder`. For minting assets with a smart contract visit [this documentation](/apis/txbuilder/smart-contracts#minting-assets-with-plutus-script).

Firstly, we need to define the `forgingScript` with `ForgeScript`. We use the first wallet address as the "minting address" (you can use other addresses).

```tsx
const changeAddress = await wallet.getChangeAddress();
const forgingScript = ForgeScript.withOneSignature(changeAddress);
```

Then, we define the metadata.

```tsx
const demoAssetMetadata = {
  name: "Mesh Token",
  image: "ipfs://QmRzicpReutwCkM6aotuKjErFCUD213DpwPq6ByuzMJaua",
  mediaType: "image/jpg",
  description: "This NFT was minted by Mesh (https://meshjs.dev/).",
};
const policyId = resolveScriptHash(forgingScript);
const tokenName = "MeshToken";
const tokenNameHex = stringToHex(tokenName);
const metadata = { [policyId]: { [tokenName]: { ...demoAssetMetadata } } };
```

Finally, we create a transaction and mint the asset with the `MeshTxBuilder` lower level APIs.

```tsx
const txBuilder = new MeshTxBuilder({
  fetcher: provider, // get a provider https://meshjs.dev/providers
  verbose: true,
});

const unsignedTx = await txBuilder
  .txIn(utxo.input.txHash, utxo.input.outputIndex)
  .mint("1", policyId, tokenName)
  .mintingScript(forgingScript)
  .changeAddress(changeAddress)
  .complete();
```

<Card>
  ### Mint Asset

  Mint an asset with a native script

  ```tsx
  import { MeshTxBuilder, ForgeScript, resolveScriptHash, stringToHex } from '@meshsdk/core';
  import type { Asset } from '@meshsdk/core';

  // See https://meshjs.dev/apis/wallets/meshwallet for how to create a new wallet instance
  const utxos = await wallet.getUtxos();
  const changeAddress = await wallet.getChangeAddress();
  const forgingScript = ForgeScript.withOneSignature(changeAddress);

  const demoAssetMetadata = {
    name: "Mesh Token",
    image: "ipfs://QmRzicpReutwCkM6aotuKjErFCUD213DpwPq6ByuzMJaua",
    mediaType: "image/jpg",
    description: "This NFT was minted by Mesh (https://meshjs.dev/).",
  };
  const policyId = resolveScriptHash(forgingScript);
  const tokenName = "MeshToken";
  const tokenNameHex = stringToHex(tokenName);
  const metadata = { [policyId]: { [tokenName]: { ...demoAssetMetadata } } };

  const txBuilder = new MeshTxBuilder({
    fetcher: provider, // get a provider https://meshjs.dev/providers
    verbose: true,
  });

  const unsignedTx = await txBuilder
    .mint("1", policyId, tokenNameHex)
    .mintingScript(forgingScript)
    .metadataValue(721, metadata)
    .changeAddress(changeAddress)
    .selectUtxosFrom(utxos)
    .complete();

  const signedTx = await wallet.signTx(unsignedTx);
  const txHash = await wallet.submitTx(signedTx);
  ```
</Card>


## Minting Multiple Assets

Minting multiple assets with a single transaction is a common operation in blockchain applications. Like minting single assets, you can mint multiple assets by calling `mint()` and `mintingScript` multiple times.

```tsx
const metadata = {};
metadata[policyId] = {};
for (let i = 1; i < 3; i++) {
  const tokenName = `MeshToken${i}`;
  const tokenNameHex = stringToHex(tokenName);
  metadata[policyId][tokenName] = {
    ...demoAssetMetadata,
    name: tokenName,
  };
  txBuilder.mint("1", policyId, tokenNameHex);
  txBuilder.mintingScript(forgingScript);
}
```

You add the metadata object by calling the `metadataValue()` method.

```tsx
const txBuilder = new MeshTxBuilder({
  fetcher: provider, // get a provider https://meshjs.dev/providers
  verbose: true,
});

txBuilder
  .metadataValue(721, metadata)
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos);

const unsignedTx = await txBuilder.complete();
const signedTx = await wallet.signTx(unsignedTx);
const txHash = await wallet.submitTx(signedTx);
```

<Card>
  ### Mint Multiple Assets [!toc]

  Mint multiple assets with a single transaction

  ```tsx
  import { MeshTxBuilder, ForgeScript, resolveScriptHash, stringToHex } from '@meshsdk/core';
  import type { Asset } from '@meshsdk/core';
  import { useWallet } from "@meshsdk/react";

  const { wallet, connected } = useWallet();

  const utxos = await wallet.getUtxos();
  const changeAddress = await wallet.getChangeAddress();
  const forgingScript = ForgeScript.withOneSignature(changeAddress);

  const policyId = resolveScriptHash(forgingScript);

  const txBuilder = new MeshTxBuilder({
    fetcher: provider, // get a provider https://meshjs.dev/providers
    verbose: true,
  });

  const metadata = {};
  metadata[policyId] = {};
  for (let i = 1; i < 3; i++) {
    const tokenName = `MeshToken${i}`;
    const tokenNameHex = stringToHex(tokenName);
    metadata[policyId][tokenName] = {
      ...demoAssetMetadata,
      name: tokenName,
    };
    txBuilder.mint("1", policyId, tokenNameHex);
    txBuilder.mintingScript(forgingScript);
  }

  txBuilder
    .metadataValue(721, metadata)
    .changeAddress(changeAddress)
    .selectUtxosFrom(utxos);

  const unsignedTx = await txBuilder.complete();
  const signedTx = await wallet.signTx(unsignedTx);
  const txHash = await wallet.submitTx(signedTx);
  ```
</Card>


## Burning assets

Like minting assets, we need to define the `forgingScript` with `ForgeScript`. We use the first wallet address as the "minting address". Note that, assets can only be burned by its minting address.

```tsx
const usedAddress = await wallet.getUsedAddresses();
const address = usedAddress[0];
const forgingScript = ForgeScript.withOneSignature(address);
```

Then, we resolve the policy ID and hex of the token name by calling `txBuilder.mint("-1", policyId, tokenNameHex)`

```tsx
const policyId = resolveScriptHash(forgingScript);
const tokenNameHex = stringToHex("MeshToken");
```

Finally, we create a transaction and burn the asset with the lower level APIs.

```tsx
const txBuilder = new MeshTxBuilder({
  fetcher: provider, // get a provider https://meshjs.dev/providers
  verbose: true,
});

const unsignedTx = await txBuilder
  .mint("-1", policyId, tokenNameHex)
  .mintingScript(forgingScript)
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();
```

<Card>
  ### Burn Native Assets [!toc]

  Burn native assets

  **Asset Unit**
  `d9312da562da182b02322fd8acb536f37eb9d29fba7c49dc172555274d657368546f6b656e`

  ```tsx
  import { ForgeScript, resolveScriptHash, stringToHex } from "@meshsdk/core";
  import { useWallet } from "@meshsdk/react";

  const { wallet, connected } = useWallet();

  const utxos = await wallet.getUtxos();
  const changeAddress = await wallet.getChangeAddress();

  const forgingScript = ForgeScript.withOneSignature(changeAddress);

  const policyId = resolveScriptHash(forgingScript);
  const tokenNameHex = stringToHex("MeshToken");

  const txBuilder = new MeshTxBuilder({
    fetcher: provider, // get a provider https://meshjs.dev/providers
    verbose: true,
  });

  const unsignedTx = await txBuilder
    .mint("-1", policyId, tokenNameHex)
    .mintingScript(forgingScript)
    .changeAddress(changeAddress)
    .selectUtxosFrom(utxos)
    .complete();

  const signedTx = await wallet.signTx(unsignedTx);
  const txHash = await wallet.submitTx(signedTx);
  ```
</Card>


## Minting Assets with Native Script

The minting and burning examples above demonstrate using a one-signature native script. Here we explain the underlying logic for native script minting.

With `MeshTxBuilder`, you just need to call `.mint()` and provide a script to mint or burn native script tokens:

```tsx
txBuilder
  .mint("1", policyId, tokenNameHex)
  .mintingScript(forgingScript)
```

On top of these two core steps, you can attach metadata with .metadataValue() and then construct the transaction as needed.

<Card>
  ### Mint Assets with Native Script [!toc]

  Mint native assets with Native Script

  ```tsx
  const utxos = await wallet.getUtxos();
  const changeAddress = await wallet.getChangeAddress();

  const { pubKeyHash: keyHash } = deserializeAddress(changeAddress);

  const nativeScript: NativeScript = {
    type: "all",
    scripts: [
      {
        type: "before",
        slot: "99999999",
      },
      {
        type: "sig",
        keyHash: keyHash,
      },
    ],
  };
  const forgingScript = ForgeScript.fromNativeScript(nativeScript);

  const policyId = resolveScriptHash(forgingScript);
  const tokenName = "MeshToken";
  const tokenNameHex = stringToHex(tokenName);
  const metadata = { [policyId]: { [tokenName]: { ...demoAssetMetadata } } };

  const txBuilder = new MeshTxBuilder({
    fetcher: provider, // get a provider https://meshjs.dev/providers
    verbose: true,
  });


  const unsignedTx = await txBuilder
    .mint("1", policyId, tokenNameHex)
    .mintingScript(forgingScript)
    .metadataValue(721, metadata)
    .changeAddress(changeAddress)
    .invalidHereafter(99999999)
    .selectUtxosFrom(utxos)
    .complete();

  const signedTx = await wallet.signTx(unsignedTx);
  const txHash = await wallet.submitTx(signedTx);
  ```
</Card>


## Minting Assets with Plutus Script

Plutus script minting with `MeshTxBuilder` starts with any of the below script version indicators:

```tsx
.mintPlutusScriptV1()
.mintPlutusScriptV2()
.mintPlutusScriptV3()
```

Followed by specifying the minting information:

```tsx
.mint(quantity: string, policy: string, name: string)
```

Similar to unlocking, minting or burning tokens, the Plutus script requires providing a redeemer and the script itself. However, no datum information is needed in minting or burning.

**Providing a Script**

The actual script can be either provided through `mintTxInReference` method by attaching an on-chain UTxO reference, or by providing a Cbor encoded script.

- (i) Reference script
```tsx
.mintTxInReference(txHash: string, txIndex: number)
```

- (ii) Supplying script
```tsx
.mintingScript(scriptCbor: string)
```

**Minting Redeemer**

Redeemer can be provided in different **data types**. If your MeshTxBuilder does not include an `evaluator` instance, you can also provide your budget for the unlock with this redeemer endpoint

```tsx
.mintRedeemerValue(redeemer: Data | object | string, type: "Mesh" | "CBOR" | "JSON", exUnits?: Budget)
```

<Card>
  ### Mint Assets with Plutus Script [!toc]

  Mint native assets with Plutus Script. For this example, the Plutus script expects a data field of 'mesh'.

  **Redeemer value:** `mesh`

  ```tsx
  const utxos = await wallet.getUtxos();
  const collateral: UTxO = (await wallet.getCollateral())[0]!;
  const changeAddress = await wallet.getChangeAddress();

  const policyId = resolveScriptHash(demoPlutusMintingScript, "V2");
  const tokenName = 'mesh';
  const tokenNameHex = stringToHex(tokenName);
  const metadata = { [policyId]: { [tokenName]: { ...demoAssetMetadata } } };

  const txBuilder = new MeshTxBuilder({
    fetcher: provider, // get a provider https://meshjs.dev/providers
    verbose: true,
  });

  const unsignedTx = await txBuilder
    .mintPlutusScriptV2()
    .mint("1", policyId, tokenNameHex)
    .mintingScript(demoPlutusMintingScript)
    .mintRedeemerValue(mConStr0(['mesh']))
    .metadataValue(721, metadata)
    .changeAddress(changeAddress)
    .selectUtxosFrom(utxos)
    .txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address,
    )
    .complete();

  const signedTx = await wallet.signTx(unsignedTx, true);
  const txHash = await wallet.submitTx(signedTx);
  ```
</Card>


## Minting Assets with CIP-68 Metadata standard

Minting CIP-68 tokens with `MeshTxBuilder` means 2 consecutive sets of minting APIs. The first is to mint the token with the `100` label, and the second is to mint the token with the `222` label:



```tsx
txBuilder
  .mintPlutusScriptV2()
  .mint("1", policyId, CIP68_100(tokenNameHex))
  .mintingScript(scriptCode)
  .mintRedeemerValue(mConStr0([]))
  .mintPlutusScriptV2()
  .mint("1", policyId, CIP68_222(tokenNameHex))
  .mintingScript(scriptCode)
  .mintRedeemerValue(mConStr0([]))
```

A side note, Mesh also provides the utility function of `CIP68_100(tokenNameHex: string)` and `CIP68_222(tokenNameHex: string)` to help easily construct the token names as needed. So you dont have to memorize the prefix bytes to correctly mint the CIP68-compliant tokens.

<Card>
  ### Mint Assets with CIP68 metadata standard [!toc]

  Mint assets with CIP68 metadata standard where two assets are issued, one referencing the other user token.

  **Token Name:** `Test1`

  ```tsx
  const usedAddress = await wallet.getUsedAddresses();
  const address = usedAddress[0];

  if (address === undefined) {
    throw "Address not found";
  }

  const userTokenMetadata = {
    name: userInput,
    image: "ipfs://QmRzicpReutwCkM6aotuKjErFCUD213DpwPq6ByuzMJaua",
    mediaType: "image/jpg",
    description: "Hello world - CIP68",
  };

  const alawysSucceedPlutusScript: PlutusScript = {
    code: demoPlutusAlwaysSucceedScript,
    version: "V1",
  };

  const { address: scriptAddress } = serializePlutusScript(
    alawysSucceedPlutusScript,
  );

  const utxos = await wallet.getUtxos();

  if (!utxos || utxos.length <= 0) {
    throw "No UTxOs found in wallet";
  }

  const scriptCode = applyParamsToScript(oneTimeMintingPolicy, [
    mTxOutRef(utxos[0]?.input.txHash!, utxos[0]?.input.outputIndex!),
  ]);

  const collateral: UTxO = (await wallet.getCollateral())[0]!;
  const changeAddress = await wallet.getChangeAddress();

  const policyId = resolveScriptHash(scriptCode, "V2");
  const tokenName = 'Test1';
  const tokenNameHex = stringToHex(tokenName);

  const txBuilder = new MeshTxBuilder({
    fetcher: provider, // get a provider https://meshjs.dev/providers
    verbose: true,
  });

  const unsignedTx = await txBuilder
    .txIn(
      utxos[0]?.input.txHash!,
      utxos[0]?.input.outputIndex!,
      utxos[0]?.output.amount!,
      utxos[0]?.output.address!,
    )
    .mintPlutusScriptV2()
    .mint("1", policyId, CIP68_100(tokenNameHex))
    .mintingScript(scriptCode)
    .mintRedeemerValue(mConStr0([]))
    .mintPlutusScriptV2()
    .mint("1", policyId, CIP68_222(tokenNameHex))
    .mintingScript(scriptCode)
    .mintRedeemerValue(mConStr0([]))
    .txOut(scriptAddress, [
      { unit: policyId + CIP68_100(tokenNameHex), quantity: "1" },
    ])
    .txOutInlineDatumValue(metadataToCip68(userTokenMetadata))
    .changeAddress(changeAddress)
    .selectUtxosFrom(utxos)
    .txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address,
    )
    .complete();

  const signedTx = await wallet.signTx(unsignedTx, true);
  const txHash = await wallet.submitTx(signedTx);
  ```
</Card>


## Minting Royalty Token

Royalty tokens are a special type of token that allow the creator to collect a royalty fee. This proposed standard will allow for uniform royalty distributions across the secondary market space. Read CIP-27 for more information.

The implementation of royalty tokens is very simple â€“ minting a token with the `777` label, with "rate", and "addr" in the metadata.

Here is the example of the metadata:

```tsx
const assetMetadata = {
  rate: '0.2',
  addr: 'addr_test1vpvx0sacufuypa2k4sngk7q40zc5c4npl337uusdh64kv0c7e4cxr'
};
```

<Card>
  ### Mint Native Assets [!toc]

  Mint native assets with ForgeScript

  **Rate:** `0.2`

  **Address:** `addr_test1vpvx0sacufuypa2k4sngk7q40zc5c4npl337uusdh64kv0c7e4cxr`

  ```tsx
  const utxos = await wallet.getUtxos();
  const usedAddress = await wallet.getUsedAddresses();
  const address = usedAddress[0];

  if (address === undefined) {
    throw "No address found";
  }

  const forgingScript = ForgeScript.withOneSignature(address);
  const policyId = resolveScriptHash(forgingScript);

  const assetMetadata: RoyaltiesStandard = {
    rate: '0.2',
    address: 'addr_test1vpvx0sacufuypa2k4sngk7q40zc5c4npl337uusdh64kv0c7e4cxr',
  };

  const txBuilder = new MeshTxBuilder({
    fetcher: provider, // get a provider https://meshjs.dev/providers
    verbose: true,
  });

  const unsignedTx = await txBuilder
    .mint("1", policyId, "")
    .mintingScript(forgingScript)
    .metadataValue(777, assetMetadata)
    .changeAddress(address)
    .selectUtxosFrom(utxos)
    .complete();

  const signedTx = await wallet.signTx(unsignedTx);
  const txHash = await wallet.submitTx(signedTx);
  ```
</Card>
