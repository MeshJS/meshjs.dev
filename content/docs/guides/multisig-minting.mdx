---
title: "Multi-Signatures Transaction"
---
import Link from  "fumadocs-core/link";

Multi-signature (multi-sig) transactions require more than one signature before broadcasting. Include two or more signers, such as wallets (<Link href="/apis/wallets/browserwallet">Browser Wallet</Link> or <Link href="/apis/wallets/meshwallet">Mesh Wallet</Link>) or Plutus scripts.

Build a multi-sig transaction for minting. Two wallets are involved:

1. Client wallet (user buying the asset)
2. Application wallet (holds the forging script)

Connect to the user's CIP30 wallet (`BrowserWallet`) to request a minting transaction. The backend application wallet (`MeshWallet`) builds the transaction, and the user signs it. <Link href="https://github.com/MeshJS/mesh/blob/main/apps/playground/src/pages/guides/multisig-minting/demo.tsx">Check out the code here</Link>.

## Connect wallet (client)

Connect the client's wallet and obtain their address and UTXOs.

Connect with `BrowserWallet`:

```tsx
import { BrowserWallet } from '@meshsdk/core';
const wallet = await BrowserWallet.enable(walletName);
```

Or use the `CardanoWallet` component:

```tsx
import { CardanoWallet, useWallet } from "@meshsdk/react";

export default function Page() {
  const { wallet, connected } = useWallet();

  return <CardanoWallet />
}
```

Get the client's address and UTXOs:

```tsx
const recipientAddress = await wallet.getChangeAddress();
const utxos = await wallet.getUtxos();
```

The change address receives the minted NFTs and change. The client's UTXOs are needed to build the transaction.

Select required UTXOs using `experimentalSelectUtxos`:

```tsx
const assetMap = new Map<Unit, Quantity>();
assetMap.set("lovelace", mintingFee);
const selectedUtxos = experimentalSelectUtxos(assetMap, utxos, "5000000");
```

`experimentalSelectUtxos` returns required UTXOs. `mintingFee` is the minting cost; `5000000` buffers the transaction fee.

Send `selectedUtxos` and `recipientAddress` to the backend.

## Build transaction (application)

Build the minting transaction.

This guide assumes a backend server (e.g., Vercel API, NestJS, ExpressJS).

Initialize a <Link href="/providers">blockchain provider</Link> and <Link href="/apis/wallets/meshwallet">Mesh Wallet</Link>.

```tsx
const provider = new BlockfrostProvider(
  '<blockfrost key here>'
);

const meshWallet = new MeshWallet({
  networkId: 0,
  fetcher: provider,
  submitter: provider,
  key: {
    type: 'mnemonic',
    words: yourMnemonic,
  },
});
```

Define the forging script:

```tsx
const meshWalletAddress = meshWallet.getChangeAddress();
const forgingScript = ForgeScript.withOneSignature(meshWalletAddress);
```

Define `AssetMetadata`:

```tsx
const assetName = 'MeshToken';

const assetMetadata: AssetMetadata = {
  name: 'Mesh Token',
  image: 'ipfs://QmRzicpReutwCkM6aotuKjErFCUD213DpwPq6ByuzMJaua',
  mediaType: 'image/jpg',
  description: 'This NFT was minted by Mesh (https://meshjs.dev/).',
};
```

Create the transaction using MeshTxBuilder. Set inputs, mint asset, send lovelace, set change address, and build:

```tsx
import { MeshTxBuilder, resolveScriptHash, stringToHex } from '@meshsdk/core';

const policyId = resolveScriptHash(forgingScript);
const tokenNameHex = stringToHex(assetName);
const metadata = { [policyId]: { [assetName]: assetMetadata } };

const txBuilder = new MeshTxBuilder({
  fetcher: provider,
});

// Add user's UTXOs as inputs
userUtxos.forEach(utxo => {
  txBuilder.txIn(utxo.input.txHash, utxo.input.outputIndex, utxo.output.amount, utxo.output.address);
});

const unsignedTx = await txBuilder
  .mint("1", policyId, tokenNameHex)
  .mintingScript(forgingScript)
  .txOut(recipientAddress, [{ unit: policyId + tokenNameHex, quantity: "1" }])
  .txOut(bankWalletAddress, [{ unit: "lovelace", quantity: mintingFee }])
  .metadataValue(721, metadata)
  .changeAddress(recipientAddress)
  .complete();
```

Send the transaction to the client.

## Sign transaction (client)

Obtain the client's signature. The wallet prompts for a password. Set partial sign to `true`.

```tsx
const signedTx = await wallet.signTx(unsignedTx, true);
```

## Sign transaction (application)

The backend signs with the application wallet:

```tsx
const meshWalletSignedTx = await meshWallet.signTx(signedTx, true);
```

## Submit transaction (application)

Submit the transaction:

```tsx
const txHash = await meshWallet.submitTx(meshWalletSignedTx);
```

You can now build multi-sig transactions.

<Link herf="https://github.com/MeshJS/mesh/blob/main/apps/playground/src/pages/guides/multisig-minting/demo.tsx">Check out the code here</Link>.

