---
title: "Aiken Hello World"
---
import Link from "fumadocs-core/link";
import { HowToSchema } from "@/components/seo";

<HowToSchema
  name="Build Aiken Smart Contracts for Cardano"
  description="Write a smart contract in Aiken and create transactions to lock and unlock assets on the Cardano blockchain."
  totalTime="PT60M"
  steps={[
    { name: "Install Aiken CLI", text: "Install Aiken using aikup on Linux/MacOS or cargo install aiken from sources on all platforms." },
    { name: "Verify installation", text: "Run aiken -V to verify the Aiken CLI installation." },
    { name: "Create Aiken project", text: "Run aiken meshjs/hello_world to create a new Aiken project, then cd hello_world and aiken check." },
    { name: "Write validator", text: "Create validators/hello_world.ak with datum, redeemer types and validation logic." },
    { name: "Compile contract", text: "Run aiken build to compile the smart contract and generate plutus.json blueprint." },
    { name: "Prepare frontend", text: "Install cbor package, copy plutus.json to data folder, and import required Mesh packages." },
    { name: "Import contract", text: "Create PlutusScript from compiled code and resolve script address." },
    { name: "Create locking transaction", text: "Build transaction to lock assets at script address with datum containing owner hash." },
    { name: "Create unlock transaction", text: "Retrieve UTXO, create redeemer with Hello World message, and build unlock transaction." }
  ]}
/>

Aiken is a functional programming language for Cardano smart contract development. It prioritizes on-chain execution and offers a user-friendly approach for building secure and efficient smart contracts.

This tutorial walks you through writing a smart contract in Aiken and creating two transactions to lock and unlock assets on the Cardano blockchain.

Try the <Link href="https://aiken-template.meshjs.dev/">live demo</Link>. View the code on the <Link href="https://github.com/MeshJS/aiken-next-ts-template/tree/main">GitHub repository</Link>.

## System setup

Set up your system to compile Aiken smart contracts. Skip this section if you have already set up your system or do not wish to compile the contract.

Check the installation instructions on the <Link href="https://aiken-lang.org/installation-instructions">Aiken website</Link> for more information.

### Using aikup (on Linux & MacOS only) [!toc]

Linux and MacOS users can use the utility tool to download and manage Aiken's pre-compiled executables.

Install the Aiken CLI:

```tsx
$ curl -sSfL https://install.aiken-lang.org | bash
$ aikup
```

### From sources (all platforms) [!toc]

Aiken is written in Rust. Install Rust and Cargo to compile the smart contract. Install Rust via the <Link href="https://www.rust-lang.org/">Rust website</Link>.

Install Cargo, the Rust package manager, via the <Link href="https://doc.rust-lang.org/stable/book/ch01-01-installation.html">Cargo website</Link>.

Verify installation:

```tsx
$ rustc --version
$ cargo --version
```

Install the Aiken CLI:

```tsx
$ cargo install aiken
```

### Check your installation [!toc]

Verify the Aiken CLI installation:

```tsx
$ aiken -V
```

If issues arise, check the <Link href="https://aiken-lang.org/installation-instructions">Aiken website</Link>.

## Writing a smart contract with Aiken

Write a smart contract in Aiken and create two transactions to lock and unlock assets.

Read more about this example on the <Link href="https://aiken-lang.org/example--hello-world/basics">Aiken website</Link>.

### Create a new project [!toc]

Create a new project. Refer to <Link href="/guides/nextjs">this guide</Link> for creating a new Next.js project.

Create a new Aiken project within this project folder:

```tsx
$ aiken meshjs/hello_world
$ cd hello_world
$ aiken check
```

Run `aiken check` to verify your project.

### Write the smart contract [!toc]

Create `validators/hello_world.ak`:

```tsx
use aiken/hash.{Blake2b_224, Hash}
use aiken/list
use aiken/transaction.{ScriptContext}
use aiken/transaction/credential.{VerificationKey}

type Datum {
  owner: Hash<Blake2b_224, VerificationKey>,
}

type Redeemer {
  msg: ByteArray,
}

validator {
  fn hello_world(datum: Datum, redeemer: Redeemer, context: ScriptContext) -> Bool {
    let must_say_hello =
      redeemer.msg == "Hello, World!"

    let must_be_signed =
      list.has(context.transaction.extra_signatories, datum.owner)

    must_say_hello && must_be_signed
  }
}
```

This validator checks that the redeemer message is "Hello, World!" and that the transaction is signed by the datum owner. Returns `true` if both conditions are met; otherwise `false`.

Compile the smart contract:

```tsx
$ aiken build
```

This generates `plutus.json` in the root folder. This file is a <Link href="https://cips.cardano.org/cip/CIP-57">CIP-0057 Plutus blueprint</Link>, describing your on-chain contract and its binary interface.

## Creating locking transaction

### Preparing the frontend [!toc]

Prepare the frontend to allow users to lock and unlock assets.

Install `cbor`:

```tsx
$ npm install cbor
```

Create a `data` folder and copy `plutus.json` into it.

Open `pages/index.tsx` and import the packages:

```tsx
import {
  resolvePlutusScriptAddress,
  MeshTxBuilder,
  KoiosProvider,
  resolveDataHash,
  resolvePaymentKeyHash,
} from "@meshsdk/core";
import type { PlutusScript, Data } from "@meshsdk/core";
import { CardanoWallet, useWallet } from "@meshsdk/react";

import plutusScript from "../data/plutus.json";
import cbor from "cbor";
```

### Importing the contract [!toc]

Import the contract:

```tsx
const script: PlutusScript = {
  code: cbor
    .encode(Buffer.from(plutusScript.validators[0].compiledCode, "hex"))
    .toString("hex"),
  version: "V2",
};
const scriptAddress = resolvePlutusScriptAddress(script, 0);
```

Use `plutus.json` to create the script and `resolvePlutusScriptAddress` to resolve the address.

We encode the compiled validator code with cbor because the validator uses a flat format, unlike the format expected by cardano-cli and the serialization library.

### Locking assets [!toc]

Create the transaction to lock assets:

```tsx
const utxos = await wallet.getUtxos();
const changeAddress = await wallet.getChangeAddress();

const hash = resolvePaymentKeyHash((await wallet.getUsedAddresses())[0]);
const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const txBuilder = new MeshTxBuilder({
  fetcher: koios,
});

const unsignedTx = await txBuilder
  .txOut(scriptAddress, [{ unit: "lovelace", quantity: "5000000" }])
  .txOutDatumHashValue(datum)
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();

const signedTx = await wallet.signTx(unsignedTx);
const txHash = await wallet.submitTx(signedTx);
```

This transaction locks assets. `resolvePaymentKeyHash` resolves the wallet's key hash. `txOut` sends lovelace to the script address with `txOutDatumHashValue` attaching the datum.

The contract requires the owner's address in the datum. We build, sign, and submit the transaction.

## Unlocking assets

Create the transaction to unlock assets.

Retrieve the UTXO of the locked assets:

```tsx
async function _getAssetUtxo({ scriptAddress, asset, datum }) {
  const utxos = await koios.fetchAddressUTxOs(scriptAddress, asset);

  const dataHash = resolveDataHash(datum);

  let utxo = utxos.find((utxo: any) => {
    return utxo.output.dataHash == dataHash;
  });

  return utxo;
}
```

Create the unlock transaction:

```tsx
const scriptAddress = resolvePlutusScriptAddress(script, 0);

const address = (await wallet.getUsedAddresses())[0];
const hash = resolvePaymentKeyHash(address);
const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const assetUtxo = await _getAssetUtxo({
  scriptAddress: scriptAddress,
  asset: "lovelace",
  datum: datum,
});

const redeemer: Data = { alternative: 0, fields: ['Hello, World!'] };

const utxos = await wallet.getUtxos();
const changeAddress = await wallet.getChangeAddress();
const collateral = await wallet.getCollateral();

const txBuilder = new MeshTxBuilder({
  fetcher: koios,
});

// create the unlock asset transaction
const unsignedTx = await txBuilder
  .spendingPlutusScriptV2()
  .txIn(assetUtxo.input.txHash, assetUtxo.input.outputIndex)
  .txInDatumValue(datum)
  .txInRedeemerValue(redeemer)
  .txInScript(script.code)
  .txOut(address, assetUtxo.output.amount)
  .requiredSignerHash(hash)
  .txInCollateral(
    collateral[0].input.txHash,
    collateral[0].input.outputIndex,
    collateral[0].output.amount,
    collateral[0].output.address,
  )
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();

const signedTx = await wallet.signTx(unsignedTx, true);
const txHash = await wallet.submitTx(signedTx);
```

This transaction unlocks assets. `resolvePlutusScriptAddress` resolves the script address. `resolvePaymentKeyHash` resolves the wallet's key hash.

`_getAssetUtxo` retrieves the locked asset UTXO. `spendingPlutusScriptV2` indicates we're spending from a Plutus V2 script. `txInDatumValue` provides the datum, `txInRedeemerValue` provides the redeemer, and `txInScript` provides the script. `requiredSignerHash` sets the required signer.

The validator requires "Hello, World!" as the redeemer message. We build, sign, and submit the transaction.

Check the full code on <Link href="https://github.com/MeshJS/aiken-next-ts-template/blob/main/pages/index.tsx">GitHub</Link>.