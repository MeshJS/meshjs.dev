---
title: "Getting Started with Aiken Smart Contracts and Mesh SDK"
description: "Build your first Cardano smart contract with Aiken and interact with it using the Mesh TypeScript blockchain SDK for dApp development."
---
import Link from "fumadocs-core/link";
import { HowToSchema } from "@/components/seo";

<HowToSchema
  name="Build Aiken Smart Contracts for Cardano"
  description="Write a smart contract in Aiken and create transactions to lock and unlock assets on the Cardano blockchain."
  totalTime="PT60M"
  steps={[
    { name: "Install Aiken CLI", text: "Install Aiken using aikup on Linux/MacOS or cargo install aiken from sources on all platforms." },
    { name: "Verify installation", text: "Run aiken -V to verify the Aiken CLI installation." },
    { name: "Create Aiken project", text: "Run aiken meshjs/hello_world to create a new Aiken project, then cd hello_world and aiken check." },
    { name: "Write validator", text: "Create validators/hello_world.ak with datum, redeemer types and validation logic." },
    { name: "Compile contract", text: "Run aiken build to compile the smart contract and generate plutus.json blueprint." },
    { name: "Prepare frontend", text: "Install cbor package, copy plutus.json to data folder, and import required Mesh packages." },
    { name: "Import contract", text: "Create PlutusScript from compiled code and resolve script address." },
    { name: "Create locking transaction", text: "Build transaction to lock assets at script address with datum containing owner hash." },
    { name: "Create unlock transaction", text: "Retrieve UTXO, create redeemer with Hello World message, and build unlock transaction." }
  ]}
/>

Aiken is a functional programming language designed specifically for Cardano smart contracts. Combined with the Mesh Cardano SDK, you can write, deploy, and interact with Cardano smart contracts using familiar JavaScript Web3 tooling.

This tutorial builds a complete "Hello World" Cardano smart contract—you'll write the on-chain validator in Aiken, then use the Mesh TypeScript blockchain SDK to create transactions that lock and unlock assets in your Cardano dApp development.

**Resources:**
- <Link href="https://aiken-template.meshjs.dev/">Live demo</Link>
- <Link href="https://github.com/MeshJS/aiken-next-ts-template/tree/main">GitHub repository</Link>

## How Do You Install Aiken?

**Linux/MacOS** - Use the aikup installer:

```tsx
curl -sSfL https://install.aiken-lang.org | bash
aikup
```

**All platforms** - Install from source via Cargo (requires <Link href="https://www.rust-lang.org/">Rust</Link>):

```tsx
cargo install aiken
```

Verify your installation:

```tsx
aiken -V
```

See the <Link href="https://aiken-lang.org/installation-instructions">Aiken installation guide</Link> for troubleshooting.

## How Do You Write an Aiken Smart Contract?

Create a new Aiken project:

```tsx
aiken meshjs/hello_world
cd hello_world
aiken check
```

Create `validators/hello_world.ak` with the validator logic:

```tsx
use aiken/hash.{Blake2b_224, Hash}
use aiken/list
use aiken/transaction.{ScriptContext}
use aiken/transaction/credential.{VerificationKey}

type Datum {
  owner: Hash<Blake2b_224, VerificationKey>,
}

type Redeemer {
  msg: ByteArray,
}

validator {
  fn hello_world(datum: Datum, redeemer: Redeemer, context: ScriptContext) -> Bool {
    let must_say_hello =
      redeemer.msg == "Hello, World!"

    let must_be_signed =
      list.has(context.transaction.extra_signatories, datum.owner)

    must_say_hello && must_be_signed
  }
}
```

This validator enforces two conditions:
1. The redeemer message must be "Hello, World!"
2. The transaction must be signed by the datum owner

Compile the contract:

```tsx
aiken build
```

This generates `plutus.json`—a <Link href="https://cips.cardano.org/cip/CIP-57">CIP-0057 Plutus blueprint</Link> containing your compiled validator.

## How Do You Lock Assets at the Script Address?

Set up your frontend (see <Link href="/guides/nextjs">Next.js guide</Link>) and install dependencies:

```tsx
npm install cbor
```

Copy `plutus.json` to a `data` folder and import the required packages:

```tsx
import {
  resolvePlutusScriptAddress,
  MeshTxBuilder,
  KoiosProvider,
  resolveDataHash,
  resolvePaymentKeyHash,
} from "@meshsdk/core";
import type { PlutusScript, Data } from "@meshsdk/core";
import { CardanoWallet, useWallet } from "@meshsdk/react";

import plutusScript from "../data/plutus.json";
import cbor from "cbor";
```

Load the compiled contract and resolve its address:

```tsx
const script: PlutusScript = {
  code: cbor
    .encode(Buffer.from(plutusScript.validators[0].compiledCode, "hex"))
    .toString("hex"),
  version: "V2",
};
const scriptAddress = resolvePlutusScriptAddress(script, 0);
```

The CBOR encoding converts Aiken's flat format to the format expected by Cardano serialization libraries in the Mesh Cardano SDK.

Build the locking transaction—this sends ADA to the script with a datum containing the owner's public key hash:

```tsx
const utxos = await wallet.getUtxos();
const changeAddress = await wallet.getChangeAddress();

const hash = resolvePaymentKeyHash((await wallet.getUsedAddresses())[0]);
const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const txBuilder = new MeshTxBuilder({
  fetcher: koios,
});

const unsignedTx = await txBuilder
  .txOut(scriptAddress, [{ unit: "lovelace", quantity: "5000000" }])
  .txOutDatumHashValue(datum)
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();

const signedTx = await wallet.signTx(unsignedTx);
const txHash = await wallet.submitTx(signedTx);
```

## How Do You Unlock Assets from the Script?

First, find the UTxO containing your locked assets:

```tsx
async function _getAssetUtxo({ scriptAddress, asset, datum }) {
  const utxos = await koios.fetchAddressUTxOs(scriptAddress, asset);

  const dataHash = resolveDataHash(datum);

  let utxo = utxos.find((utxo: any) => {
    return utxo.output.dataHash == dataHash;
  });

  return utxo;
}
```

Build the unlock transaction with the correct redeemer message:

```tsx
const scriptAddress = resolvePlutusScriptAddress(script, 0);

const address = (await wallet.getUsedAddresses())[0];
const hash = resolvePaymentKeyHash(address);
const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const assetUtxo = await _getAssetUtxo({
  scriptAddress: scriptAddress,
  asset: "lovelace",
  datum: datum,
});

const redeemer: Data = { alternative: 0, fields: ['Hello, World!'] };

const utxos = await wallet.getUtxos();
const changeAddress = await wallet.getChangeAddress();
const collateral = await wallet.getCollateral();

const txBuilder = new MeshTxBuilder({
  fetcher: koios,
});

// create the unlock asset transaction
const unsignedTx = await txBuilder
  .spendingPlutusScriptV2()
  .txIn(assetUtxo.input.txHash, assetUtxo.input.outputIndex)
  .txInDatumValue(datum)
  .txInRedeemerValue(redeemer)
  .txInScript(script.code)
  .txOut(address, assetUtxo.output.amount)
  .requiredSignerHash(hash)
  .txInCollateral(
    collateral[0].input.txHash,
    collateral[0].input.outputIndex,
    collateral[0].output.amount,
    collateral[0].output.address,
  )
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();

const signedTx = await wallet.signTx(unsignedTx, true);
const txHash = await wallet.submitTx(signedTx);
```

Key components of the unlock transaction:
- `spendingPlutusScriptV2()` — Indicates a Plutus V2 script spend
- `txInDatumValue` — Provides the original datum
- `txInRedeemerValue` — Provides "Hello, World!" to satisfy the validator
- `requiredSignerHash` — Ensures the owner signs the transaction

## What Should You Explore Next?

- View the <Link href="https://github.com/MeshJS/aiken-next-ts-template/blob/main/pages/index.tsx">complete source code</Link>
- Learn more at the <Link href="https://aiken-lang.org/example--hello-world/basics">Aiken documentation</Link>
- Explore <Link href="/guides/vesting">building a vesting contract</Link>
- Read about <Link href="/guides/smart-contract-transactions">smart contract transaction patterns</Link>