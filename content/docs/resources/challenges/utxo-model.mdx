---
title: "Cardano UTXO Model Explained: How It Works"
description: "Learn Cardano's UTXO model vs Ethereum's accounts for dApp development. Understand eUTXO, why transactions fail, and how Mesh Cardano SDK handles complexity."
---
import Link from "next/link";
import { HowToSchema, FAQSchema } from "@/components/seo";

<HowToSchema
  name="Work with Cardano's UTXO Model Using Mesh SDK"
  description="Learn to work with Cardano's UTXO model using the Mesh TypeScript blockchain SDK for automatic UTXO selection and change calculation."
  totalTime="PT15M"
  steps={[
    { name: "Understand UTXO basics", text: "Learn that UTXOs are discrete unspent outputs that must be fully consumed in transactions, unlike Ethereum account balances." },
    { name: "Install Mesh SDK", text: "Run npm install @meshsdk/core to add the Cardano SDK to your JavaScript Web3 project." },
    { name: "Use automatic UTXO selection", text: "Let MeshTxBuilder handle UTXO selection, change calculation, and transaction construction automatically." }
  ]}
/>

<FAQSchema
  faqs={[
    {
      question: "What is the UTXO model in Cardano?",
      answer: "UTXO stands for Unspent Transaction Output. Instead of accounts with balances like Ethereum, Cardano tracks discrete 'coins' (UTXOs) that transactions consume entirely and create new ones as outputs. Your wallet balance is the sum of all UTXOs you control."
    },
    {
      question: "Why does Cardano use UTXO instead of accounts like Ethereum?",
      answer: "The UTXO model provides deterministic transaction validation, better parallelization for Cardano smart contracts, enhanced privacy through new addresses per transaction, and simpler verification since transaction validity depends only on its inputs."
    },
    {
      question: "How is Cardano's eUTXO different from Bitcoin's UTXO?",
      answer: "Cardano's extended UTXO (eUTXO) adds datum (arbitrary data attached to UTXOs), Cardano smart contract validators, native multi-asset support, and reference scripts/inputs for more efficient contract execution."
    },
    {
      question: "Why do I get 'insufficient funds' with enough balance on Cardano?",
      answer: "This happens because ADA might be locked alongside native tokens in UTXOs, minimum UTXO requirements prevent small outputs, or UTXOs are fragmented. A TypeScript blockchain SDK like Mesh handles these scenarios automatically."
    },
    {
      question: "Do I need to understand UTXOs to build Cardano dApps?",
      answer: "A basic understanding helps, but the Mesh Cardano SDK abstracts most complexity. You can build functional dApps without deep UTXO knowledge, though understanding the model helps debug edge cases and optimize performance."
    }
  ]}
/>

The UTXO (Unspent Transaction Output) model is Cardano's fundamental architecture for tracking value in dApp development. Unlike Ethereum's account-based model where balances update in place, Cardano represents value as discrete outputs consumed and recreated in each transaction. The Mesh Cardano SDK abstracts this complexity for JavaScript Web3 developers, letting you describe transaction intent while handling UTXO selection automatically.

**Key Takeaway:** Your Cardano wallet balance is the sum of discrete UTXOs, not a single number. Every transaction consumes UTXOs entirely and creates new ones—understanding this prevents most Cardano dApp development issues.

## What Is the UTXO Model?

UTXO stands for Unspent Transaction Output. Instead of account balances, Cardano tracks discrete "coins" that must be fully consumed and recreated in transactions. This differs fundamentally from Ethereum and requires a mental shift for JavaScript Web3 developers.

### How Does Ethereum's Account Model Work?

Ethereum uses accounts with balances—familiar from traditional banking:

```
Account: 0x123...
Balance: 100 ETH
```

Sending 10 ETH updates the number in place. Transactions execute sequentially; final state reflects all operations. Intuitive, but limits parallelization.

### How Does Cardano's UTXO Model Work?

Cardano tracks individual unspent outputs:

```
UTXO 1: 50 ADA (from tx abc123)
UTXO 2: 30 ADA (from tx def456)
UTXO 3: 20 ADA (from tx ghi789)
Total: 100 ADA
```

To send 10 ADA:

1. Select UTXOs as inputs (consumed entirely)
2. Create output for recipient (10 ADA)
3. Create change output for yourself (remaining minus fees)

Selecting UTXO 2 (30 ADA) to send 10 ADA:

```
Inputs: UTXO 2 (30 ADA) - consumed entirely
Outputs:
  - Recipient: 10 ADA (new UTXO)
  - Change: ~19.8 ADA (new UTXO, minus fee)
```

UTXO 2 is destroyed. Two new UTXOs are created.

### Why Does Cardano Use UTXO?

| Advantage | Description |
|-----------|-------------|
| Deterministic validation | Transaction validity depends only on inputs, not global state |
| Simple verification | Light clients verify without tracking all accounts |
| Natural parallelism | Transactions on different UTXOs execute in parallel |
| Privacy features | New addresses per transaction complicate analysis |
| Explicit resources | Outputs declare contents; no unexpected state changes |

## What Is the Extended UTXO Model (eUTXO)?

Cardano extends Bitcoin's basic UTXO model to support Cardano smart contracts through eUTXO. This enables sophisticated on-chain logic while maintaining UTXO benefits like deterministic validation. The Mesh TypeScript blockchain SDK provides high-level APIs for all eUTXO features.

| Feature | Purpose |
|---------|---------|
| **Datums** | Arbitrary data attached to UTXOs for smart contract state |
| **Validators** | Scripts defining spending conditions |
| **Redeemers** | Arguments provided when spending script UTXOs |
| **Reference inputs** | Read UTXOs without consuming them |
| **Reference scripts** | On-chain scripts referenced by hash |

Example UTXO with datum:

```typescript
{
  address: "addr_script1...",
  value: { lovelace: 5000000 },
  datum: { owner: "addr1...", deadline: 1234567 }
}
```

## How Does Mesh SDK Handle UTXOs?

The Mesh TypeScript blockchain SDK lets you describe transaction intent instead of manually managing UTXOs in your React blockchain or JavaScript Web3 app. MeshTxBuilder handles selection, fees, and change automatically—you focus on what to send, not how to construct valid inputs.

```typescript
import { MeshTxBuilder, BlockfrostProvider, BrowserWallet } from "@meshsdk/core";

const provider = new BlockfrostProvider("<your-api-key>");
const wallet = await BrowserWallet.enable("eternl");

const txBuilder = new MeshTxBuilder({
  fetcher: provider,
  submitter: provider,
});

const unsignedTx = await txBuilder
  .txOut(recipientAddress, [{ unit: "lovelace", quantity: "10000000" }])
  .changeAddress(await wallet.getChangeAddress())
  .selectUtxosFrom(await wallet.getUtxos())
  .complete();

// Mesh automatically handles:
// - Optimal UTXO selection
// - Fee calculation
// - Change output creation
// - Minimum UTXO requirements
// - Token handling
```

### How Does Automatic UTXO Selection Work?

The `selectUtxosFrom` method implements intelligent coin selection:

```typescript
const utxos = await wallet.getUtxos();
const tx = await txBuilder
  .txOut(recipient, [{ unit: "lovelace", quantity: "5000000" }])
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();
```

Mesh selects UTXOs that:
- Satisfy required output value
- Minimize transaction size (fewer inputs = lower fees)
- Avoid unnecessary wallet fragmentation
- Handle tokens correctly (included in change if not sent)

### How Does Mesh Handle Native Tokens?

Tokens are bundled with ADA in UTXOs. Mesh handles this automatically:

```typescript
// Wallet has: UTXO 1 (10 ADA + 100 TokenA), UTXO 2 (5 ADA)
// You want to send 3 ADA

const tx = await txBuilder
  .txOut(recipient, [{ unit: "lovelace", quantity: "3000000" }])
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();

// Mesh selects UTXO 2 to avoid TokenA complexity
// Or ensures TokenA goes to change if UTXO 1 is needed
```

### What Are Minimum UTXO Requirements?

Every UTXO must contain minimum ADA (~1 ADA simple, more with tokens/datum). Mesh handles this:

```typescript
const tx = await txBuilder
  .txOut(recipient, [
    { unit: policyId + assetName, quantity: "1" }
    // Mesh adds minimum required ADA automatically
  ])
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();
```

## How Do I Get Started with UTXOs?

**1. View your wallet's UTXOs**

```typescript
import { BrowserWallet } from "@meshsdk/core";

const wallet = await BrowserWallet.enable("eternl");
const utxos = await wallet.getUtxos();

utxos.forEach(utxo => {
  console.log(`UTXO: ${utxo.input.txHash}#${utxo.input.outputIndex}`);
  console.log(`  Value: ${utxo.output.amount}`);
});
```

**2. Let Mesh handle UTXO selection**

```typescript
import { MeshTxBuilder, BlockfrostProvider } from "@meshsdk/core";

const provider = new BlockfrostProvider("<your-api-key>");
const txBuilder = new MeshTxBuilder({ fetcher: provider, submitter: provider });

const tx = await txBuilder
  .txOut(recipient, [{ unit: "lovelace", quantity: "5000000" }])
  .changeAddress(await wallet.getChangeAddress())
  .selectUtxosFrom(await wallet.getUtxos())
  .complete();
```

**3. Sign and submit**

```typescript
const signedTx = await wallet.signTx(tx);
const txHash = await wallet.submitTx(signedTx);
// Creates new UTXOs: recipient (5 ADA) + change (remaining - fee)
```

## How Do Cardano Smart Contracts Use UTXOs?

Cardano smart contracts use the eUTXO model to lock funds with validators that define spending conditions. The Mesh Cardano SDK provides explicit script handling for Plutus and Aiken contracts, managing datums, redeemers, and execution budgets in your dApp development workflow.

### How Do I Lock Funds to a Script?

```typescript
const tx = await txBuilder
  .txOut(scriptAddress, [{ unit: "lovelace", quantity: "10000000" }])
  .txOutDatumHashValue(datum)
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();
```

### How Do I Spend from a Script?

```typescript
const tx = await txBuilder
  .spendingPlutusScript(languageVersion)
  .txIn(scriptUtxo.input.txHash, scriptUtxo.input.outputIndex)
  .txInScript(scriptCbor)
  .txInDatumValue(datum)
  .txInRedeemerValue(redeemer)
  .txOut(recipient, outputValue)
  .txInCollateral(collateralTxHash, collateralIndex)
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();
```

### How Do Reference Inputs Work?

```typescript
// Read UTXO without consuming it
const tx = await txBuilder
  .readOnlyTxInReference(refTxHash, refIndex)
  .txOut(recipient, outputValue)
  .changeAddress(changeAddress)
  .selectUtxosFrom(utxos)
  .complete();
```

## What Are Common UTXO Pitfalls?

Three UTXO pitfalls affect most Cardano dApp development projects: fragmentation from many small transactions, concurrent transaction conflicts, and token bundle complexity. The Mesh Cardano SDK mitigates these but understanding them helps optimize your application.

### How Do I Fix UTXO Fragmentation?

Frequent small transactions create many small UTXOs, increasing fees for larger transactions. Consolidate periodically:

```typescript
const utxos = await wallet.getUtxos();
const total = utxos.reduce((sum, u) =>
  sum + BigInt(u.output.amount.find(a => a.unit === "lovelace")?.quantity || 0),
  BigInt(0)
);

const tx = await txBuilder
  .txOut(await wallet.getChangeAddress(), [
    { unit: "lovelace", quantity: total.toString() }
  ])
  .selectUtxosFrom(utxos)
  .complete();
```

### How Do I Avoid Concurrent Transaction Conflicts?

Building multiple transactions from the same UTXO set causes conflicts:

```typescript
// Wrong: both use same UTXOs
const utxos = await wallet.getUtxos();
const tx1 = await txBuilder.selectUtxosFrom(utxos).complete();
const tx2 = await txBuilder.selectUtxosFrom(utxos).complete(); // Conflict!

// Correct: wait for confirmation, then fetch fresh UTXOs
```

### How Do Token Bundles Work?

Tokens are always bundled with ADA. You must send minimum ADA with any token:

```typescript
const tx = await txBuilder
  .txOut(recipient, [
    { unit: "lovelace", quantity: "1500000" }, // Minimum ADA required
    { unit: tokenUnit, quantity: "50" }
  ])
  .changeAddress(changeAddress) // Remaining tokens go here
  .selectUtxosFrom(utxos)
  .complete();
```

## Related Challenges

- <Link href="/docs/resources/challenges/transaction-failures">Transaction Failures</Link>: Often stem from UTXO issues
- <Link href="/docs/resources/challenges/coin-selection">Coin Selection Problems</Link>: Choosing which UTXOs to use
- <Link href="/docs/resources/challenges/wallet-integration">Wallet Integration</Link>: How wallets expose UTXOs

## Next Steps

With UTXO understanding, explore the <Link href="/docs/resources/challenges">Challenges Hub</Link> for other Cardano dApp development topics or dive into <Link href="/docs">Mesh documentation</Link> for advanced TypeScript blockchain SDK patterns.
