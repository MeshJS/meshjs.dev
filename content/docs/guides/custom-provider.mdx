---
title: "Build a Custom Blockchain Provider for Your Cardano dApp"
description: "Learn how to create custom providers for the Mesh Cardano SDK using TypeScript interfaces. Connect any data source to your Cardano dApp development workflow."
---
import Link from "fumadocs-core/link";
import { HowToSchema } from "@/components/seo";

<HowToSchema
  name="Build a Custom Blockchain Provider for Cardano"
  description="Create a custom provider class that implements Mesh SDK interfaces to connect your Cardano dApp to any blockchain data source."
  totalTime="PT60M"
  steps={[
    { name: "Understand provider interfaces", text: "Review IFetcher and ISubmitter interfaces that define the contract your custom class must follow." },
    { name: "Create provider class template", text: "Start with the provider template implementing required interfaces." },
    { name: "Initialize constructor", text: "Set up network endpoints, API keys, and HTTP client configuration." },
    { name: "Implement data mapping", text: "Map data between your source and Mesh's expected types for each interface method." },
    { name: "Test and document", text: "Verify each method returns correctly typed data and document your implementation." }
  ]}
/>

A custom provider is a TypeScript class that implements Mesh SDK interfaces to connect your Cardano dApp to any blockchain data source. Whether you're using GraphQL endpoints, cardano-cli, websockets, or your own infrastructure, custom providers give you complete control over how your application fetches UTxOs, retrieves protocol parameters, and submits transactions.

This TypeScript blockchain SDK pattern lets you replace built-in providers like <Link href="https://blockfrost.io/">Blockfrost</Link> or <Link href="https://www.koios.rest/">Koios</Link> with custom implementations while maintaining full compatibility with Mesh's transaction builder. This guide walks through building a custom provider from scratch.

## What Are Provider Interfaces?

Provider interfaces define the contract your custom class must follow in the Mesh Cardano SDK. Any class implementing an interface must include all specified methods with matching signatures—this ensures your custom provider works seamlessly with Mesh's transaction builder and other Cardano dApp development features.

For example, `KoiosProvider` implements both `IFetcher` and `ISubmitter`:

```tsx
export class KoiosProvider implements IFetcher, ISubmitter {}
```

The `IFetcher` interface requires six methods for querying blockchain data:

```tsx
import type { AccountInfo, AssetMetadata, Protocol, UTxO } from '@mesh/common/types';

export interface IFetcher {
  fetchAccountInfo(address: string): Promise<AccountInfo>;
  fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
  fetchAssetAddresses(asset: string): Promise<{ address: string; quantity: string }[]>;
  fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
  fetchHandleAddress(handle: string): Promise<string>;
  fetchProtocolParameters(epoch: number): Promise<Protocol>;
}
```

See the <Link href="https://github.com/MeshJS/mesh/tree/main/packages/mesh-provider/src/types">latest interface definitions on GitHub</Link> for the complete API.

## How Do You Create a Custom Provider?

Start by reviewing <Link href="https://github.com/MeshJS/mesh/tree/main/packages/mesh-provider/src">existing provider implementations</Link> in the Mesh repository. Use the following template as your starting point:

```tsx
import { IFetcher, ISubmitter } from "@mesh/common/contracts";
import { parseHttpError } from "@mesh/common/utils";
import type {
  AccountInfo,
  AssetMetadata,
  Protocol,
  UTxO,
} from "@mesh/common/types";

export class NAMEProvider implements IFetcher, ISubmitter {
  constructor(network: "") {
    // init variables and other Javascript libraries needed
  }

  async fetchAccountInfo(address: string): Promise<AccountInfo> {
    try {
      // return <AccountInfo>{
      //   ...
      // };
    } catch (error) {
      throw parseHttpError(error);
    }
  }

  async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {
    try {
      // return <UTxO[]>[
      //   ...
      // ];
    } catch (error) {
      throw parseHttpError(error);
    }
  }

  async fetchAssetAddresses(
    asset: string
  ): Promise<{ address: string; quantity: string }[]> {
    try {
      // return AssetAddresses;
    } catch (error) {
      throw parseHttpError(error);
    }
  }

  async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {
    try {
      // return <AssetMetadata>[
      //   ...
      // ];
    } catch (error) {
      throw parseHttpError(error);
    }
  }

  async fetchHandleAddress(handle: string): Promise<string> {
    try {
      // return handleAddress;
    } catch (error) {
      throw parseHttpError(error);
    }
  }

  async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {
    try {
      // return <Protocol>{
      //   ...
      // };
    } catch (error) {
      throw parseHttpError(error);
    }
  }

  async submitTx(tx: string): Promise<string> {
    try {
      // if (status === 200)
      //   return txHash;
    } catch (error) {
      throw parseHttpError(error);
    }
  }
}
```

This template may change as interfaces evolve. Choose which interfaces to implement based on your Cardano dApp development needs—use `IFetcher` alone for read-only access, or add `ISubmitter` to submit transactions.

## How Do You Initialize the Provider Constructor?

The constructor initializes your provider with network endpoints, API keys, and any HTTP client configuration required for your TypeScript blockchain SDK integration. Here's how `KoiosProvider` sets up its Axios instance:

```tsx
private readonly _axiosInstance: AxiosInstance;

constructor(network: 'api' | 'preview' | 'preprod' | 'guild', version = 0) {
  this._axiosInstance = axios.create({
    baseURL: `https://${network}.koios.rest/api/v${version}`,
  });
}
```

## How Do You Map Data Between Your Source and Mesh Types?

Each interface method requires mapping data between your source and Mesh's expected types. Consider these factors:

1. **Query method** — How does your data source expose this information?
2. **Input mapping** — Transform Mesh's input parameters to your provider's format
3. **Output mapping** — Convert your provider's response to Mesh's expected types
4. **Error handling** — Wrap errors consistently using `parseHttpError`

Here's how `KoiosProvider` implements `fetchProtocolParameters()`, mapping Koios API responses to Mesh's `Protocol` type:

```tsx
async fetchProtocolParameters(epoch: number): Promise<Protocol> {
  try {
    const { data, status } = await this._axiosInstance.get(
      `epoch_params?_epoch_no=${epoch}`,
    );

    if (status === 200)
      return <Protocol>{
        coinsPerUTxOSize: data[0].coins_per_utxo_size,
        collateralPercent: data[0].collateral_percent,
        decentralisation: data[0].decentralisation,
        epoch: data[0].epoch_no,
        keyDeposit: data[0].key_deposit,
        maxBlockExMem: data[0].max_block_ex_mem.toString(),
        maxBlockExSteps: data[0].max_block_ex_steps.toString(),
        maxBlockHeaderSize: data[0].max_bh_size,
        maxBlockSize: data[0].max_block_size,
        maxCollateralInputs: data[0].max_collateral_inputs,
        maxTxExMem: data[0].max_tx_ex_mem.toString(),
        maxTxExSteps: data[0].max_tx_ex_steps.toString(),
        maxTxSize: data[0].max_tx_size,
        maxValSize: data[0].max_val_size.toString(),
        minFeeA: data[0].min_fee_a,
        minFeeB: data[0].min_fee_b,
        minPoolCost: data[0].min_pool_cost,
        poolDeposit: data[0].pool_deposit,
        priceMem: data[0].price_mem,
        priceStep: data[0].price_step,
      };

    throw parseHttpError(data);
  } catch (error) {
    throw parseHttpError(error);
  }
}
```

## What Should You Do After Implementation?

After implementing all required interface methods for your Cardano SDK integration:

1. **Test thoroughly** — Verify each method returns correctly typed data
2. **Handle edge cases** — Account for missing data, network errors, and rate limits
3. **Document your provider** — Help others understand your implementation

Built a provider that could benefit other Cardano developers? <Link href="https://github.com/MeshJS/mesh/pulls">Submit a pull request</Link> to share it with the community.