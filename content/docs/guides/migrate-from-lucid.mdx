---
title: "How to Migrate from Lucid to Mesh Cardano SDK"
description: "Migrate your Cardano dApp development from Lucid to Mesh with feature mapping, API comparisons, and common TypeScript blockchain SDK patterns."
---
import Link from "fumadocs-core/link";
import { HowToSchema } from "@/components/seo";

<HowToSchema
  name="Migrate from Lucid to Mesh Cardano SDK"
  description="Step-by-step migration guide from Lucid to Mesh with API mapping and code patterns."
  totalTime="PT120M"
  steps={[
    { name: "Install Mesh packages", text: "Install @meshsdk/core for base functionality and @meshsdk/react for UI components." },
    { name: "Replace provider setup", text: "Configure chosen provider class (Blockfrost, Koios, Maestro, etc.)." },
    { name: "Update wallet connection", text: "Use BrowserWallet or React hooks instead of Lucid wallet selection." },
    { name: "Refactor transaction building", text: "Map Lucid methods to Mesh equivalents using MeshTxBuilder." },
    { name: "Update smart contract code", text: "Adjust script loading and datum handling for Mesh patterns." },
    { name: "Replace data serialization", text: "Use Mesh's serializePlutusData and deserializePlutusData utilities." },
    { name: "Update tests", text: "Migrate from Lucid Emulator to Mesh testing tools like OfflineFetcher and TxTester." }
  ]}
/>

Migrating from Lucid to Mesh involves mapping equivalent APIs and adjusting to Mesh's separated architecture. Both are TypeScript blockchain SDKs for Cardano dApp development, but Mesh separates transaction building, wallet interaction, and blockchain queries into distinct components—giving you more flexibility in how you structure your application.

## Why Should You Consider Migrating to Mesh?

The Mesh Cardano SDK and Lucid both provide excellent JavaScript Web3 tooling. Factors that may influence a migration decision include:

- **Active maintenance** — Mesh receives regular updates with new Cardano features
- **TypeScript-first** — Full type definitions for better IDE support and error catching
- **React blockchain integrations** — Pre-built UI components and hooks for wallet connection
- **Provider flexibility** — Easy switching between Blockfrost, Koios, Maestro, and others
- **Cardano smart contracts tooling** — Aiken integration and transaction testing utilities

## How Do Lucid Concepts Map to Mesh?

Understanding how concepts translate between the two libraries accelerates migration:

| Lucid Concept | Mesh Equivalent | Notes |
|---------------|-----------------|-------|
| `Lucid.new()` | `MeshTxBuilder` + Provider | Mesh separates transaction building from blockchain queries |
| `lucid.selectWallet()` | `BrowserWallet.enable()` | Similar CIP-30 wallet connection |
| `lucid.newTx()` | `new MeshTxBuilder()` | Transaction builder instantiation |
| `tx.payToAddress()` | `txBuilder.txOut()` | Output construction |
| `tx.attachSpendingValidator()` | `txBuilder.spendingPlutusScript()` | Script attachment |
| `tx.complete()` | `txBuilder.complete()` | Transaction finalization |
| `tx.sign().complete()` | `wallet.signTx()` | Signing workflow differs |
| `Emulator` | `OfflineFetcher` + `OfflineEvaluator` | Testing utilities |
| `Data.to()` | `serializePlutusData()` | Datum/redeemer serialization |
| `Data.from()` | `deserializePlutusData()` | Data deserialization |

## How Does Wallet Connection Differ?

**Lucid** combines provider setup and wallet selection in a single flow, creating a configured instance that handles both blockchain queries and wallet operations.

**Mesh** separates these concerns. Use `BrowserWallet` for CIP-30 wallet interactions and provider classes for blockchain data. This separation lets you swap providers without changing wallet code.

For React blockchain applications, Mesh offers the `useWallet` hook and `CardanoWallet` component, simplifying wallet state management with built-in UI.

## How Does Transaction Building Differ?

Both libraries use builder patterns, but with different method naming and chaining approaches.

**Key differences:**

- Mesh uses explicit input/output methods (`txIn`, `txOut`) rather than combined pay methods
- Script witnesses attach differently—Mesh requires explicit script and datum/redeemer association
- Mesh's `complete()` returns a serialized transaction requiring a separate signing step
- Collateral handling is more explicit in Mesh

**Mesh transaction flow:**

1. Create `MeshTxBuilder` with provider
2. Set inputs with `txIn()` or `spendingPlutusScript()` for smart contracts
3. Set outputs with `txOut()`
4. Call `complete()` to build the transaction
5. Sign with wallet using `signTx()`
6. Submit with provider using `submitTx()`

## How Do You Migrate Smart Contract Code?

Both libraries support Plutus and Cardano smart contracts, but Mesh integrates tightly with Aiken tooling.

**Mesh advantages for contracts:**

- Blueprint parsing utilities for Aiken-generated contracts
- Type-safe datum and redeemer construction from blueprint schemas
- Transaction testing with `TxTester` for validation before submission
- Offline evaluation for script execution simulation

**Migration pattern for validators:**

Replace Lucid's `SpendingValidator` construction with Mesh's approach of reading compiled scripts from Aiken blueprints. Mesh's `applyParamsToScript` handles parameterized validators similarly to Lucid's `applyParamsToScript`.

## How Do You Configure Providers in Mesh?

Lucid requires provider selection at initialization. Mesh allows provider injection into transaction builders, making it easy to switch providers per operation or environment.

**Supported providers:**

- `BlockfrostProvider` — Most common choice for production
- `KoiosProvider` — Free tier available, good for testing
- `MaestroProvider` — Advanced indexing features
- `OgmiosProvider` — Self-hosted option
- `YaciProvider` — Local development chains

Each provider implements the same interface, enabling seamless switching.

## How Does Data Serialization Work in Mesh?

Lucid uses a custom `Data` class with tagged union types. Mesh provides explicit serialization functions with TypeScript types derived from Aiken schemas.

**Serialization utilities:**

- `serializePlutusData()` — Convert JavaScript objects to CBOR
- `deserializePlutusData()` — Parse on-chain data
- `meshToCbor()` and `cborToMesh()` — Lower-level conversions
- Blueprint-derived types for type-safe data construction

## How Do You Migrate Tests?

**Lucid's Emulator** provides an in-memory blockchain for testing.

**Mesh equivalents:**

- `OfflineFetcher` — Mock blockchain state for testing
- `OfflineEvaluator` — Simulate script execution without a node
- `TxTester` — Validate transactions against expected outcomes
- Yaci integration for local development chains

## What's the Migration Checklist?

When migrating an existing application:

1. **Install Mesh packages** — `@meshsdk/core` for base functionality, `@meshsdk/react` for UI components
2. **Replace provider setup** — Configure chosen provider class
3. **Update wallet connection** — Use `BrowserWallet` or React hooks
4. **Refactor transaction building** — Map Lucid methods to Mesh equivalents
5. **Update smart contract code** — Adjust script loading and datum handling
6. **Replace data serialization** — Use Mesh's serialization utilities
7. **Update tests** — Migrate from Emulator to Mesh testing tools

## What Are Common Migration Issues?

**Type mismatches** — Mesh uses different type names for addresses, values, and UTxOs. Import types from `@meshsdk/core` and update type annotations.

**Signing flow** — Mesh requires explicit signing after `complete()`. Don't forget to call `wallet.signTx(unsignedTx)` before submission.

**Script references** — Mesh handles reference scripts differently. Use `txInReference` for consuming referenced scripts.

**Fee calculation** — Both libraries handle fees automatically, but Mesh requires the change address explicitly in many cases.

## Where Can You Get Help?

If you encounter migration issues:

- Review <Link href="/apis/txbuilder">Transaction Builder documentation</Link> for API details
- Check <Link href="/guides/smart-contract-transactions">Smart Contract Transactions guide</Link> for contract patterns
- Join the <Link href="https://discord.gg/dH48jH3BKa">Mesh Discord</Link> for community support

Migration complexity depends on your application's use of Lucid-specific features. Simple Cardano dApp development projects with basic transactions migrate quickly, while complex Cardano smart contracts interactions require more careful mapping.
